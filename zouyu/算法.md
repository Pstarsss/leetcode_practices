### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)


给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

 

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```

 

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由 **可打印的 ASCII** 字符组成

**题解：**

使用双指针，左右两指针分别判断是否为元音字母，当都为元音字母时交换

**代码：**

```java
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        if (n <= 1) return s;

        char[] arr = s.toCharArray();

        int left = 0, right = n - 1;
        while (left < right) {
            // 相等则交换
            if (isVowel(arr[left]) && isVowel(arr[right])) {
                char tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left++;
                right--;
            }

            // 左指针不是元音，右移一位
            if (!isVowel(arr[left])) left++;
            // 右指针不是元音，左移一位
            if (!isVowel(arr[right])) right--;
        }
        
        return new String(arr);
    }
    public boolean isVowel(char c) {
        return c == 'a' || c == 'A'
                || c == 'e' || c == 'E'
                || c == 'i' || c == 'I'
                || c == 'o' || c == 'O'
                || c == 'u' || c == 'U';
    }
}
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- 1 <= s.length <= 104
- s 仅由小写英文组成
- 1 <= k <= 104

**题解：**

该问题需要注意边缘问题：

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

交换时，需要注意结尾位置，

不足 k 个，则交换发生在 i 位置和 n 位置之间，

不足 2k 个，则正常发生交换。

**代码：**

```
class Solution {
    public String reverseStr(String s, int k) {

        int num = s.length();
        if (num <= 1) {
            return s;
        }
        char[] arr = s.toCharArray();

        for(int i = 0; i < num; i += 2*k) {
            int left = i;
            int right = Math.min(i + k, num) - 1;
            while(left < right) {
                char temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left ++;
                right --;
            }
        }

        return new String(arr);
    }
}
```

### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

```
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

**题解：**

由异或运算特性可知：

```
a ^ 0 = a
a ^ a = 0
```

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        int eor = 0;
        //异或数组中所有数，得到最后的结果就是所求数
        for(int num: nums) {
            eor ^= num;
        }
        return eor;
    }
}
```

#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**

- 1 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次

**题解：**

使用hash冲突解决问题，具体解法见代码

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            //产生冲突，次数加一
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        //遍历map，找到value值为1的key即为出现一次的数
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3：**

```
输入：nums = [0,1]
输出：[1,0]
```

**提示：**

- 2 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- 除两个只出现一次的整数外，nums 中的其他数字都出现两次

**题解：**

还是利用异或的特性解题，具体解法见代码注释。

**代码：**

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int eor = 0;
        for(int num : nums) {
            eor ^= num;
        }
        //此时eor = a ^ b
        //因为 a != b ，所以eor != 0
        //所以eor中一定存在某一个比特位为1
        //求出eor中最右边的一个比特位为1的数
        int rightFirst = eor & (~eor + 1);
        //由该比特位可将数组中的数划分为两类
        //其中 a, b 各占一类
        int aOrB = 0;
        for(int num : nums) {
            if((num & rightFirst) == 0) {
                aOrB ^= num;
            }
        }
        //所得到的结果aOrB为 a or b
        return new int[]{aOrB, eor ^ aOrB};
    }
}
```

#### [881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)

第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。

返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

 

**示例 1：**

```
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
```

**示例 2：**

```
输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)
```

**示例 3：**

```
输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
```

**提示：**

```
1 <= people.length <= 50000
1 <= people[i] <= limit <= 30000
```

**题解：**

贪心算法，详情见代码解析

**代码：**

```java
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        //定义所需要的船的数量
        int count = 0;
        //将人的体重进行排序，以方便找出体重最大的人和体重最小的人
        Arrays.sort(people);
        int left = 0;
        int right = people.length - 1;
        //要减少船的数量，必须尽量将两个人放入船内
        while(left <= right) {
            //判断最重的人和最轻的人是否能放入一个船内
            if(people[left] + people[right] <= limit) {
                left++;
                right--;
            } else {
                //如果不能，最重的人只能单独坐一艘船
                right--;
            }
            //船的数量 + 1
            count++;
        }
        //返回船的数量
        return count;

    }
}
```

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -109 <= nums1[i], nums2[j] <= 109

**题解：**

参考归并排序的merge过程

**代码：**

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //定义两个数组的指针
        int i = 0,j = 0,k = 0;
        //创建一个新数组临时存放排好序的元素
        int[] arr = new int[m + n];
        //依次遍历两数组中的元素，小的放入新数组
        while(i < m && j < n) {
            arr[k++] = nums1[i] <= nums2[j] ? nums1[i++] : nums2[j++];
        }
        //复制nums1以上比较剩下的元素
        while(i < m) {
            arr[k++] = nums1[i++];
        }
        //复制nums2以上比较剩下的元素
        while(j < n) {
            arr[k++] = nums2[j++];
        }
        //将临时数组中的元素拷贝回nums1
        for(int a = 0;a < m + n; a++) {
            nums1[a] = arr[a];
        }
    }
}
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)


给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

 

**进阶：**

- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

**题解：**

1. 使用hash冲突解决问题，定义一个map，key保留重复出现的数，value保留重复出现次数；
2. 巧解：因为出现次数大于n/2，所以排序后中点位置一定为该数。

**代码：**

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ > (nums.length >> 1)) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length >> 1];
    }
}
```

#### [1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。

请返回 nums 的动态和。

 

**示例 1：**

```
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
```

**示例 2：**

```
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
```

**示例 3：**

```
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
```

**提示：**

- 1 <= nums.length <= 1000
- -10^6 <= nums[i] <= 10^6

**题解：**

见代码

**代码：**

```
class Solution {
    public int[] runningSum(int[] nums) {
        int n = nums.length;
        for (int i = 1; i < n; i++) {
            nums[i] += nums[i - 1];
        }
        return nums;
    }
}
```

#### [724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 

**示例 1：**

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

**提示：**

- 1 <= nums.length <= 104
- -1000 <= nums[i] <= 1000

**题解：**

1. 遍历一遍求出总和sum
2. 遍历第二遍求中心索引左半和leftSum
   - 同时根据sum和leftSum 计算中心索引右半和rightSum
   - 判断leftSum和rightSum是否相同

**代码：**

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int len = nums.length;
        if(len == 1) {
            return 0;
        }
        //求出数组总和
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //
        int leftSum = 0;
        for(int i = 0; i < len; i++) {
            if((leftSum * 2 + nums[i]) == sum) {
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
}
```

#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

 

**进阶：**

你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

**示例 1：**

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 2：**

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 3：**

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 4：**

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

**提示：**

- n == nums.length
- 1 <= n <= 104
- 0 <= nums[i] <= n
- nums 中的所有数字都 独一无二

**题解：**

好像和以前的一道题（只出现一次的数字）有异曲同工之处。看了大家的题解，异或操作（`^`）是一种很好的方式，不用考虑sum越界问题。

举个例子：

- 0 ^ 4 = 4
- 4 ^ 4 = 0

那么，就可以不用求和，直接使用异或运算`^`进行 抵消，剩下的数字就是缺失的了。

再举个例子：

- 1^1^2^2^3 = 3

**代码：**

```java
class Solution {
    public int missingNumber(int[] nums) {
        int res = nums.length;
        for(int i = 0; i < nums.length; i++) {
            res ^= i;
            res ^= nums[i];
        }
        return res;
    }
}
```

#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

 

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

**题解：**

第一种解法：

​	利用set去重，后比较长度

第二种解法：

​	利用hash快速查找，见代码二

**代码：**

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> res = new HashSet<Integer>();
        for(int num:nums)
            res.add(num);
        return res.size() < nums.length;
    }
}
```

```
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            if(freq.getOrDefault(num, 0) == 1) {
                return true;
            }
            freq.put(num, 1);
        }
        return false;
    }
}
```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

 

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

**题解：**

快慢指针，先让快指针走k步，然后两个指针同步走，当快指针走到头时，慢指针就是链表倒数第k个节点。

**代码：**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode befor = head, after = head;
        while(befor.next != null && k > 1) {
            befor = befor.next;
            k--;
        }
        while(befor.next != null) {
            befor = befor.next;
            after = after.next;
        }
        return after;
    }
}
```

#### [10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

**提示：**

- 0 <= n <= 100

**题解：**

依题意：

该题仅需求出 F(N) = F(N - 1) + F(N - 2) , 所以仅保留三个变量即可，以降低空间复杂度

详解见代码

**代码：**

```java
class Solution {
    public int fib(int n) {
        if(n < 2) {
            return n;
        }
        final int Mod = 1000000007;
        int p = 0, q = 1, r = 0;
        for(int i = 2; i <= n; i++) {
            //r = p + q 取模 
            r = (p + q) % Mod;
            //p q 向前移动
            p = q;
            q = r;
        }
        return r;

    }
}
```

#### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

 

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

**示例 4：**

```
输入：x = -101
输出：false
```

**提示：**

- -231 <= x <= 231 - 1

**题解：**

负数不可能为回文数

对 x 取余10，后再除以10，求出 x 的回文数

后与 x 作比较

**代码：**

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x < 0) {
            return false;
        }
        int cur = 0;
        int num = x;
        //求出 x 的回文数 cur
        while(num != 0) {
            cur = cur * 10 + num % 10;
            num /= 10;
        }
        return cur == x;
    }
}
```

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

**题解：**

数组有序即可使用二分查找，时间复杂度为O(log n)

**代码：**

```java
class Solution {
    public int search(int[] nums, int target) {

        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = left + ((right - left) >> 1);
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }

}
```

递归二分

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        
        return fun(nums, l, r, target);
    }

    public int fun(int[] arr, int l, int r, int t) {
        if (l >= r) return arr[l] == t ? l : -1;
        int mid = l + (r - l ) / 2;
        if (arr[mid] >= t) r = mid;
        else l = mid + 1;
        return fun(arr, l, r, t);
    }   
}
```




