### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)


给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

 

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```

 

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由 **可打印的 ASCII** 字符组成

**题解：**

使用双指针，左右两指针分别判断是否为元音字母，当都为元音字母时交换

**代码：**

```java
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        if (n <= 1) return s;

        char[] arr = s.toCharArray();

        int left = 0, right = n - 1;
        while (left < right) {
            // 相等则交换
            if (isVowel(arr[left]) && isVowel(arr[right])) {
                char tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left++;
                right--;
            }

            // 左指针不是元音，右移一位
            if (!isVowel(arr[left])) left++;
            // 右指针不是元音，左移一位
            if (!isVowel(arr[right])) right--;
        }
        
        return new String(arr);
    }
    public boolean isVowel(char c) {
        return c == 'a' || c == 'A'
                || c == 'e' || c == 'E'
                || c == 'i' || c == 'I'
                || c == 'o' || c == 'O'
                || c == 'u' || c == 'U';
    }
}
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- 1 <= s.length <= 104
- s 仅由小写英文组成
- 1 <= k <= 104

**题解：**

该问题需要注意边缘问题：

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

交换时，需要注意结尾位置，

不足 k 个，则交换发生在 i 位置和 n 位置之间，

不足 2k 个，则正常发生交换。

**代码：**

```
class Solution {
    public String reverseStr(String s, int k) {

        int num = s.length();
        if (num <= 1) {
            return s;
        }
        char[] arr = s.toCharArray();

        for(int i = 0; i < num; i += 2*k) {
            int left = i;
            int right = Math.min(i + k, num) - 1;
            while(left < right) {
                char temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left ++;
                right --;
            }
        }

        return new String(arr);
    }
}
```

### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

```
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

**题解：**

由异或运算特性可知：

```
a ^ 0 = a
a ^ a = 0
```

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        int eor = 0;
        //异或数组中所有数，得到最后的结果就是所求数
        for(int num: nums) {
            eor ^= num;
        }
        return eor;
    }
}
```

#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**

- 1 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次

**题解：**

使用hash冲突解决问题，具体解法见代码

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            //产生冲突，次数加一
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        //遍历map，找到value值为1的key即为出现一次的数
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3：**

```
输入：nums = [0,1]
输出：[1,0]
```

**提示：**

- 2 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- 除两个只出现一次的整数外，nums 中的其他数字都出现两次

**题解：**

还是利用异或的特性解题，具体解法见代码注释。

**代码：**

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int eor = 0;
        for(int num : nums) {
            eor ^= num;
        }
        //此时eor = a ^ b
        //因为 a != b ，所以eor != 0
        //所以eor中一定存在某一个比特位为1
        //求出eor中最右边的一个比特位为1的数
        int rightFirst = eor & (~eor + 1);
        //由该比特位可将数组中的数划分为两类
        //其中 a, b 各占一类
        int aOrB = 0;
        for(int num : nums) {
            if((num & rightFirst) == 0) {
                aOrB ^= num;
            }
        }
        //所得到的结果aOrB为 a or b
        return new int[]{aOrB, eor ^ aOrB};
    }
}
```

#### [881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)

第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。

返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

 

**示例 1：**

```
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
```

**示例 2：**

```
输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)
```

**示例 3：**

```
输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
```

**提示：**

```
1 <= people.length <= 50000
1 <= people[i] <= limit <= 30000
```

**题解：**

贪心算法，详情见代码解析

**代码：**

```java
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        //定义所需要的船的数量
        int count = 0;
        //将人的体重进行排序，以方便找出体重最大的人和体重最小的人
        Arrays.sort(people);
        int left = 0;
        int right = people.length - 1;
        //要减少船的数量，必须尽量将两个人放入船内
        while(left <= right) {
            //判断最重的人和最轻的人是否能放入一个船内
            if(people[left] + people[right] <= limit) {
                left++;
                right--;
            } else {
                //如果不能，最重的人只能单独坐一艘船
                right--;
            }
            //船的数量 + 1
            count++;
        }
        //返回船的数量
        return count;

    }
}
```

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -109 <= nums1[i], nums2[j] <= 109

**题解：**

参考归并排序的merge过程

**代码：**

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //定义两个数组的指针
        int i = 0,j = 0,k = 0;
        //创建一个新数组临时存放排好序的元素
        int[] arr = new int[m + n];
        //依次遍历两数组中的元素，小的放入新数组
        while(i < m && j < n) {
            arr[k++] = nums1[i] <= nums2[j] ? nums1[i++] : nums2[j++];
        }
        //复制nums1以上比较剩下的元素
        while(i < m) {
            arr[k++] = nums1[i++];
        }
        //复制nums2以上比较剩下的元素
        while(j < n) {
            arr[k++] = nums2[j++];
        }
        //将临时数组中的元素拷贝回nums1
        for(int a = 0;a < m + n; a++) {
            nums1[a] = arr[a];
        }
    }
}
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)


给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

 

**进阶：**

- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

**题解：**

1. 使用hash冲突解决问题，定义一个map，key保留重复出现的数，value保留重复出现次数；
2. 巧解：因为出现次数大于n/2，所以排序后中点位置一定为该数。

**代码：**

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ > (nums.length >> 1)) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length >> 1];
    }
}
```




