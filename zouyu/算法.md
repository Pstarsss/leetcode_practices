### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)


给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

 

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```

 

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由 **可打印的 ASCII** 字符组成

**题解：**

使用双指针，左右两指针分别判断是否为元音字母，当都为元音字母时交换

**代码：**

```java
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        if (n <= 1) return s;

        char[] arr = s.toCharArray();

        int left = 0, right = n - 1;
        while (left < right) {
            // 相等则交换
            if (isVowel(arr[left]) && isVowel(arr[right])) {
                char tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left++;
                right--;
            }

            // 左指针不是元音，右移一位
            if (!isVowel(arr[left])) left++;
            // 右指针不是元音，左移一位
            if (!isVowel(arr[right])) right--;
        }
        
        return new String(arr);
    }
    public boolean isVowel(char c) {
        return c == 'a' || c == 'A'
                || c == 'e' || c == 'E'
                || c == 'i' || c == 'I'
                || c == 'o' || c == 'O'
                || c == 'u' || c == 'U';
    }
}
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- 1 <= s.length <= 104
- s 仅由小写英文组成
- 1 <= k <= 104

**题解：**

该问题需要注意边缘问题：

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

交换时，需要注意结尾位置，

不足 k 个，则交换发生在 i 位置和 n 位置之间，

不足 2k 个，则正常发生交换。

**代码：**

```
class Solution {
    public String reverseStr(String s, int k) {

        int num = s.length();
        if (num <= 1) {
            return s;
        }
        char[] arr = s.toCharArray();

        for(int i = 0; i < num; i += 2*k) {
            int left = i;
            int right = Math.min(i + k, num) - 1;
            while(left < right) {
                char temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left ++;
                right --;
            }
        }

        return new String(arr);
    }
}
```

### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

```
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

**题解：**

由异或运算特性可知：

```
a ^ 0 = a
a ^ a = 0
```

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        int eor = 0;
        //异或数组中所有数，得到最后的结果就是所求数
        for(int num: nums) {
            eor ^= num;
        }
        return eor;
    }
}
```

#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**

- 1 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次

**题解：**

使用hash冲突解决问题，具体解法见代码

**代码：**

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            //产生冲突，次数加一
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        //遍历map，找到value值为1的key即为出现一次的数
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3：**

```
输入：nums = [0,1]
输出：[1,0]
```

**提示：**

- 2 <= nums.length <= 3 * 104
- -231 <= nums[i] <= 231 - 1
- 除两个只出现一次的整数外，nums 中的其他数字都出现两次

**题解：**

还是利用异或的特性解题，具体解法见代码注释。

**代码：**

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int eor = 0;
        for(int num : nums) {
            eor ^= num;
        }
        //此时eor = a ^ b
        //因为 a != b ，所以eor != 0
        //所以eor中一定存在某一个比特位为1
        //求出eor中最右边的一个比特位为1的数
        int rightFirst = eor & (~eor + 1);
        //由该比特位可将数组中的数划分为两类
        //其中 a, b 各占一类
        int aOrB = 0;
        for(int num : nums) {
            if((num & rightFirst) == 0) {
                aOrB ^= num;
            }
        }
        //所得到的结果aOrB为 a or b
        return new int[]{aOrB, eor ^ aOrB};
    }
}
```




